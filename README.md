<div align="center">
<img width="100%" src="https://capsule-render.vercel.app/api?type=waving&color=gradient&customColorList=6,11,20&height=180&section=header&text=Welcome%20Coder!&fontSize=42&fontColor=fff&animation=twinkling&fontAlignY=32" />
<img src="https://readme-typing-svg.herokuapp.com?font=Fira+Code&weight=600&size=28&duration=3000&pause=800&color=F75C7E&center=true&vCenter=true&multiline=true&repeat=true&width=900&height=100&lines=%E2%9A%A1+Where+bugs+are+features+in+disguise;%F0%9F%8E%AF+Turning+caffeine+into+code+since+forever;%F0%9F%94%A5+90+days+of+relentless+DSA+mastery;%E2%9D%84%EF%B8%8F+Winter+is+here...+so+is+greatness!" alt="Typing SVG" />
<br>
<h1>
  <img src="https://raw.githubusercontent.com/Tarikul-Islam-Anik/Animated-Fluent-Emojis/master/Emojis/Activities/Sparkles.png" width="35px" />
  <span style="
    background: linear-gradient(135deg, #667eea 0%, #764ba2 25%, #f093fb 50%, #f5576c 75%, #fa709a 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    font-weight: 900;
    font-size: 3.2em;
  ">TUF WinterArc Challenge 2025</span>
  <img src="https://raw.githubusercontent.com/Tarikul-Islam-Anik/Animated-Fluent-Emojis/master/Emojis/Activities/Sparkles.png" width="35px" />
</h1>
<img src="https://readme-typing-svg.herokuapp.com?font=Fira+Code&weight=500&size=20&pause=1000&color=A78BFA&center=true&vCenter=true&width=600&lines=%E2%9D%84%EF%B8%8F+90+Days+|+One+Goal+|+Pure+Mastery+%E2%9D%84%EF%B8%8F;%F0%9F%9A%80+Consistency+beats+talent+%F0%9F%9A%80;%F0%9F%A7%A0+Building+bulletproof+logic+%F0%9F%A7%A0" alt="Sub Typing" />
<br>Crafted with 💜 by Sonam Narula

<p align="center">
  <img src="https://img.shields.io/badge/🔥_Challenge-TUF_WinterArc-FF4154?style=for-the-badge&labelColor=1a1b27&borderRadius=10" />
  <img src="https://img.shields.io/badge/⚡_Target-Striver's_A2Z_Sheet-A78BFA?style=for-the-badge&labelColor=1a1b27" />
  <img src="https://img.shields.io/badge/☕_Energy-Unlimited_Coffee-D97706?style=for-the-badge&labelColor=1a1b27" />
  <img src="https://img.shields.io/badge/💻_Weapon-C++17-00599C?style=for-the-badge&logo=cplusplus&logoColor=white&labelColor=1a1b27" />
  <img src="https://img.shields.io/badge/🎯_Mode-Beast_Mode_ON-10B981?style=for-the-badge&labelColor=1a1b27" />
</p>
<img src="https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif" width="100%">
</div>

## 🎮 Mission Control Center

| 🎯 Mission | 🗓️ Timeline | 📚 Roadmap | 🧪 Formula | 🏆 Prize |
|-----------|-----------|-----------|-----------|---------|
| Conquer DSA, one algorithm at a time | 90 Days of unwavering dedication | Striver's A2Z DSA Course Sheet | Practice → Debug → Master → Repeat() | Elite problem-solving skills + Bragging rights |

> 💭 *"Code is like humor. When you have to explain it, it's bad."* — Cory House

---

## 📊 Real-Time Analytics Dashboard

<div align="center">

### 🎯 Journey Metrics

<img src="https://img.shields.io/badge/Days_Completed-05%2F90-667eea?style=for-the-badge&logo=target&logoColor=white&labelColor=1a1b27" />
<img src="https://img.shields.io/badge/Streak-🔥_5_days-f5576c?style=for-the-badge&labelColor=1a1b27" />
<img src="https://img.shields.io/badge/Topics_Mastered-05-10b981?style=for-the-badge&logo=checkmarx&logoColor=white&labelColor=1a1b27" />
<img src="https://img.shields.io/badge/☕_Coffee_Consumed-∞-d97706?style=for-the-badge&labelColor=1a1b27" />
<img src="https://img.shields.io/badge/💪_Motivation-9999%25-a78bfa?style=for-the-badge&labelColor=1a1b27" />

<br><br>

### 📈 Progress Visualization

| Week | Days | Status | Progress |
|------|------|--------|----------|
| Week 1 | 1-7 | ⏳ In Progress | ███████░░ 5/7 |
| Week 2 | 8-14 | 🔜 Upcoming | ░░░░░░░░░ 0/7 |
| Week 3 | 15-21 | 🔜 Upcoming | ░░░░░░░░░ 0/7 |
| Week 4 | 22-28 | 🔒 Locked | ░░░░░░░░░ 0/7 |
| Week 5-13 | 29-90 | 🔒 Locked | ░░░░░░░░░ 0/62 |

<br><br>

```
@@                   🌨️  WINTERARC STATUS REPORT  ❄️                  @@
+  ✅ Days Conquered: 5                    ⏳ Remaining: 85            +
+  🏆 Topics Mastered: 5                   🎯 Accuracy: Improving      +
-  🐛 Bugs Squashed: ∞                     💤 Sleep: 404 Not Found     -
!  🔥 Motivation Level: MAXIMUM            🍕 Fuel Status: Depleting   !
```

### 🎯 Completion Rate

| Category | Progress | Status |
|----------|----------|--------|
| Basics | ████████████████████ 100% | 🎉 Complete |
| Intermediate | ░░░░░░░░░░░░░░░░░░░░ 0% | 🔜 Upcoming |
| Advanced | ░░░░░░░░░░░░░░░░░░░░ 0% | 🔒 Locked |

</div>

---

## 📚 Knowledge Repository (Days 1-5)

<details open>
<summary><b>🌟 Day 1: Language Fundamentals (C++)</b></summary>
<br>

| 📖 Theoretical Concepts | 💻 Practical Implementation |
|------------------------|----------------------------|
| **Input/Output Mastery**: Deep dive into cin, cout, stream manipulators, and formatted I/O | Built robust I/O handlers with error checking and edge case handling |
| **Function Architecture**: Declaration vs definition, pass by value/reference, return types, function overloading | Implemented modular functions for sum(), swap(), factorial() with various parameter types |
| **Time Complexity Analysis**: Big-O notation fundamentals — $O(1)$, $O(\log n)$, $O(n)$, $O(n \log n)$, $O(n^2)$ | Analyzed and optimized basic algorithms, learned to identify bottlenecks |
| **Control Flow Structures**: Mastery of if/else, switch-case, nested conditionals, ternary operators | Solved decision-making problems with multiple conditional branches |
| **Loop Mechanisms**: for, while, do-while — when to use which, loop control (break, continue) | Created efficient iteration patterns for various problem types |

🎯 **Key Takeaway**: Solid foundation in C++ syntax and algorithmic thinking established.

</details>

<details open>
<summary><b>🎨 Day 2: Pattern Engineering</b></summary>
<br>

### 📖 Theoretical Concepts

| Concept | Deep Dive |
|---------|-----------|
| **Nested Loop Architecture** | Understanding the fundamental relationship between outer and inner loops: <br>• Outer loop controls **rows** (vertical progression) <br>• Inner loop controls **columns** (horizontal progression) <br>• Loop indices determine position in 2D space <br>• Termination conditions shape pattern boundaries |
| **Spatial Reasoning & Geometry** | Mathematical approach to pattern construction: <br>• Calculating **leading spaces** using formula: `spaces = n - i` <br>• Computing **trailing spaces** for symmetry <br>• Understanding **element positioning** in grid systems <br>• Analyzing row-column dependencies: `col = f(row)` |
| **Pattern Categories** | <br>**1. Rectangular Patterns**: Fixed rows and columns <br>**2. Triangular Patterns**: Growing/shrinking elements per row <br>**3. Pyramid Patterns**: Symmetric triangles with centered elements <br>**4. Diamond Patterns**: Combined pyramids (upper + inverted) <br>**5. Number Patterns**: Arithmetic progressions in 2D space <br>**6. Alphabetic Patterns**: Character sequences with ASCII manipulation |
| **Symmetry Principles** | <br>• **Vertical Symmetry**: Mirror image across vertical axis <br>• **Horizontal Symmetry**: Mirror image across horizontal axis <br>• **Point Symmetry**: 180° rotation equivalence <br>• **Radial Symmetry**: Multiple axes of symmetry |
| **Loop Optimization** | Efficiency techniques for pattern generation: <br>• Avoiding redundant calculations inside loops <br>• Using mathematical formulas over conditional checks <br>• Minimizing nested loop depth where possible <br>• Precomputing constant values outside loops |

### 💻 Practical Implementation

```cpp
// Pattern 1: Rectangle of Stars (n x m)
for(int i = 0; i < n; i++) {
    for(int j = 0; j < m; j++) {
        cout << "* ";
    }
    cout << endl;
}

// Pattern 2: Right-Angled Triangle
for(int i = 1; i <= n; i++) {
    for(int j = 1; j <= i; j++) {
        cout << "* ";
    }
    cout << endl;
}

// Pattern 3: Inverted Right-Angled Triangle
for(int i = n; i >= 1; i--) {
    for(int j = 1; j <= i; j++) {
        cout << "* ";
    }
    cout << endl;
}

// Pattern 4: Right-Aligned Triangle (with leading spaces)
for(int i = 1; i <= n; i++) {
    for(int j = 1; j <= n - i; j++) {
        cout << "  ";
    }
    for(int j = 1; j <= i; j++) {
        cout << "* ";
    }
    cout << endl;
}

// Pattern 5: Pyramid (Centered Triangle)
for(int i = 1; i <= n; i++) {
    for(int j = 1; j <= n - i; j++) {
        cout << " ";
    }
    for(int j = 1; j <= 2*i - 1; j++) {
        cout << "*";
    }
    cout << endl;
}

// Pattern 6: Diamond Pattern
// Upper half
for(int i = 1; i <= n; i++) {
    for(int j = 1; j <= n - i; j++) cout << " ";
    for(int j = 1; j <= 2*i - 1; j++) cout << "*";
    cout << endl;
}
// Lower half
for(int i = n - 1; i >= 1; i--) {
    for(int j = 1; j <= n - i; j++) cout << " ";
    for(int j = 1; j <= 2*i - 1; j++) cout << "*";
    cout << endl;
}

// Pattern 7: Number Pyramid
for(int i = 1; i <= n; i++) {
    for(int j = 1; j <= i; j++) {
        cout << j << " ";
    }
    cout << endl;
}

// Pattern 8: Palindrome Number Pyramid
for(int i = 1; i <= n; i++) {
    for(int j = 1; j <= i; j++) {
        cout << j;
    }
    for(int j = i - 1; j >= 1; j--) {
        cout << j;
    }
    cout << endl;
}

// Pattern 9: Hollow Rectangle
for(int i = 1; i <= n; i++) {
    for(int j = 1; j <= m; j++) {
        if(i == 1 || i == n || j == 1 || j == m) {
            cout << "* ";
        } else {
            cout << "  ";
        }
    }
    cout << endl;
}

// Pattern 10: Butterfly Pattern
for(int i = 1; i <= n; i++) {
    for(int j = 1; j <= i; j++) cout << "*";
    for(int j = 1; j <= 2*(n-i); j++) cout << " ";
    for(int j = 1; j <= i; j++) cout << "*";
    cout << endl;
}
for(int i = n; i >= 1; i--) {
    for(int j = 1; j <= i; j++) cout << "*";
    for(int j = 1; j <= 2*(n-i); j++) cout << " ";
    for(int j = 1; j <= i; j++) cout << "*";
    cout << endl;
}
```

### 🎯 Key Patterns Mastered (20+)
- ✅ Solid Rectangle & Square
- ✅ Right-Angled Triangle (All 4 orientations)
- ✅ Pyramid & Inverted Pyramid
- ✅ Diamond Pattern
- ✅ Hollow Rectangle & Hollow Triangle
- ✅ Number Pyramid (Sequential)
- ✅ Floyd's Triangle
- ✅ Pascal's Triangle
- ✅ Palindrome Number Pattern
- ✅ Alphabet Patterns (A-Z)
- ✅ Butterfly Pattern
- ✅ Hourglass Pattern
- ✅ Zigzag Pattern
- ✅ Rhombus Pattern
- ✅ Plus (+) and Cross (X) Patterns

🎯 **Key Takeaway**: Pattern problems are the foundation of spatial thinking and loop mastery. They teach you to visualize problems in 2D space, break complex shapes into mathematical formulas, and write clean, efficient nested loop structures.

</details>

<details open>
<summary><b>🔧 Day 3: STL Powerhouse (Standard Template Library)</b></summary>
<br>

### 📖 Theoretical Concepts

| Container Type | Characteristics | Time Complexity | Use Cases |
|----------------|-----------------|-----------------|-----------|
| **vector** | Dynamic array, contiguous memory | Access: O(1), Insert/Delete at end: O(1), Middle: O(n) | Default choice for arrays, random access needed |
| **deque** | Double-ended queue | Access: O(1), Insert/Delete at both ends: O(1) | Queue/Stack hybrid, frequent front/back operations |
| **list** | Doubly linked list | Access: O(n), Insert/Delete anywhere: O(1) | Frequent insertions/deletions in middle |
| **set** | Ordered unique elements (BST) | Search/Insert/Delete: O(log n) | Maintain sorted unique elements, range queries |
| **multiset** | Ordered elements (duplicates allowed) | Search/Insert/Delete: O(log n) | Sorted collection with duplicates |
| **map** | Key-value pairs (ordered by key) | Search/Insert/Delete: O(log n) | Dictionary, frequency counting with order |
| **multimap** | Multiple values per key (ordered) | Search/Insert/Delete: O(log n) | One-to-many relationships |
| **unordered_set** | Unique elements (hash table) | Average: O(1), Worst: O(n) | Fast lookups, no order needed |
| **unordered_map** | Key-value pairs (hash table) | Average: O(1), Worst: O(n) | Fastest dictionary operations |
| **stack** | LIFO data structure | Push/Pop/Top: O(1) | DFS, expression evaluation, backtracking |
| **queue** | FIFO data structure | Push/Pop/Front: O(1) | BFS, task scheduling |
| **priority_queue** | Heap-based (max-heap default) | Insert: O(log n), Top/Pop: O(log n) | Greedy algorithms, Dijkstra's |

### 💻 Practical Implementation

```cpp
#include <bits/stdc++.h>
using namespace std;

// ============ VECTORS ============
void vectorDemo() {
    vector<int> v1;                    // Empty vector
    vector<int> v2(5);                 // 5 elements, default value 0
    vector<int> v3(5, 10);             // 5 elements, all initialized to 10
    vector<int> v4 = {1, 2, 3, 4, 5};  // Initializer list
    
    v1.push_back(10);                  // Add element at end - O(1)
    v1.pop_back();                     // Remove last element - O(1)
    v1.size();                         // Number of elements - O(1)
    v1.empty();                        // Check if empty - O(1)
    v1.front();                        // First element - O(1)
    v1.back();                         // Last element - O(1)
    v1[0];                             // Access by index - O(1)
    
    // Iteration
    for(int x : v1) cout << x << " ";
    for(auto it = v1.begin(); it != v1.end(); it++) {
        cout << *it << " ";
    }
}

// ============ SETS ============
void setDemo() {
    set<int> s;
    s.insert(10);                      // O(log n)
    s.insert(5);
    s.insert(15);
    s.insert(10);                      // Duplicate, won't be inserted
    
    if(s.find(10) != s.end()) {        // O(log n)
        cout << "Found 10" << endl;
    }
    
    s.erase(5);                        // O(log n)
    
    for(int x : s) cout << x << " ";   // Always sorted: 10 15
    
    auto it1 = s.lower_bound(10);      // Iterator to element >= 10
    auto it2 = s.upper_bound(10);      // Iterator to element > 10
}

// ============ MAPS ============
void mapDemo() {
    map<string, int> m;
    
    m["Alice"] = 95;
    m["Bob"] = 87;
    m.insert({"Charlie", 92});
    
    cout << m["Alice"] << endl;        // 95
    
    if(m.find("David") != m.end()) {
        cout << "David found" << endl;
    }
    
    for(auto& p : m) {                 // Sorted by key
        cout << p.first << ": " << p.second << endl;
    }
}

// ============ UNORDERED_MAP ============
void unorderedMapDemo() {
    unordered_map<string, int> um;
    um["X"] = 10;                      // O(1) average
    um["Y"] = 20;
    
    // No ordering guaranteed
    for(auto& p : um) {
        cout << p.first << ": " << p.second << endl;
    }
}

// ============ STACK ============
void stackDemo() {
    stack<int> st;
    st.push(10);                       // O(1)
    st.push(20);
    st.push(30);
    
    cout << st.top() << endl;          // 30
    st.pop();                          // Remove 30
    cout << st.size() << endl;         // 2
}

// ============ QUEUE ============
void queueDemo() {
    queue<int> q;
    q.push(10);                        // O(1)
    q.push(20);
    q.push(30);
    
    cout << q.front() << endl;         // 10
    cout << q.back() << endl;          // 30
    q.pop();                           // Remove 10
}

// ============ PRIORITY QUEUE ============
void priorityQueueDemo() {
    // Max-heap (default)
    priority_queue<int> pq;
    pq.push(10);
    pq.push(30);
    pq.push(20);
    cout << pq.top() << endl;          // 30
    
    // Min-heap
    priority_queue<int, vector<int>, greater<int>> minPQ;
    minPQ.push(10);
    minPQ.push(30);
    minPQ.push(20);
    cout << minPQ.top() << endl;       // 10
}

// ============ ALGORITHMS ============
void algorithmDemo() {
    vector<int> v = {5, 2, 8, 1, 9};
    
    sort(v.begin(), v.end());          // O(n log n)
    reverse(v.begin(), v.end());       // O(n)
    
    bool found = binary_search(v.begin(), v.end(), 5);  // O(log n)
    
    auto minIt = min_element(v.begin(), v.end());       // O(n)
    auto maxIt = max_element(v.begin(), v.end());       // O(n)
    
    int sum = accumulate(v.begin(), v.end(), 0);        // O(n)
    int cnt = count(v.begin(), v.end(), 5);             // O(n)
    
    next_permutation(v.begin(), v.end());               // O(n)
}
```

### 🎯 Real-World Problem Applications

1. **Frequency Counting**: Use `unordered_map<int, int>` for O(1) counting
2. **Range Queries**: Use `set` with `lower_bound()` and `upper_bound()`
3. **Sliding Window Maximum**: Use `deque` or `multiset`
4. **Top K Elements**: Use `priority_queue` (min-heap)
5. **LRU Cache**: Use `list` + `unordered_map`
6. **Duplicate Detection**: Use `unordered_set` for O(1) lookups

🎯 **Key Takeaway**: STL is your best friend in competitive programming. Master container selection, understand time complexities, and leverage built-in algorithms to write faster, cleaner code.

</details>

<details open>
<summary><b>🔢 Day 4: Mathematical Foundations</b></summary>
<br>

### 📖 Theoretical Concepts

| Topic | Theory & Formulas | Complexity |
|-------|-------------------|------------|
| **Prime Numbers** | A number > 1 with exactly two divisors: 1 and itself<br>Formula for checking: Test divisibility up to √n | O(√n) |
| **Factors/Divisors** | Numbers that divide n without remainder<br>Factors come in pairs: if `i` divides `n`, so does `n/i` | O(√n) |
| **GCD (Greatest Common Divisor)** | Largest number dividing both a and b<br>**Euclidean Algorithm**: `gcd(a, b) = gcd(b, a % b)`<br>Base case: `gcd(a, 0) = a` | O(log min(a,b)) |
| **LCM (Least Common Multiple)** | Smallest number divisible by both a and b<br>**Formula**: `LCM(a, b) = (a * b) / GCD(a, b)` | O(log min(a,b)) |
| **Armstrong Number** | n-digit number where sum of nth powers of digits equals the number<br>Example: 153 = 1³ + 5³ + 3³ | O(log n) |
| **Palindrome Number** | Number that reads same forwards and backwards<br>Example: 12321, 1001 | O(log n) |
| **Perfect Number** | Number equal to sum of its proper divisors<br>Example: 6 = 1 + 2 + 3 | O(√n) |
| **Digit Manipulation** | Extract digits: `digit = n % 10`<br>Remove last digit: `n = n / 10`<br>Reverse: Build new number from right to left | O(log n) |
| **Sieve of Eratosthenes** | Algorithm to find all primes up to n<br>Mark multiples of each prime as composite | O(n log log n) |

### 💻 Practical Implementation

```cpp
#include <bits/stdc++.h>
using namespace std;

// ============ PRIME CHECKING ============
// Optimized approach - O(√n)
bool isPrime(int n) {
    if(n <= 1) return false;
    if(n == 2) return true;
    if(n % 2 == 0) return false;
    
    for(int i = 3; i * i <= n; i += 2) {
        if(n % i == 0) return false;
    }
    return true;
}

// ============ COUNTING DIVISORS ============
// Optimized - O(√n)
int countDivisors(int n) {
    int count = 0;
    for(int i = 1; i * i <= n; i++) {
        if(n % i == 0) {
            if(i * i == n) count++;      // Perfect square
            else count += 2;             // Count both i and n/i
        }
    }
    return count;
}

// Print all divisors - O(√n)
void printDivisors(int n) {
    vector<int> divisors;
    for(int i = 1; i * i <= n; i++) {
        if(n % i == 0) {
            divisors.push_back(i);
            if(i != n / i) {
                divisors.push_back(n / i);
            }
        }
    }
    sort(divisors.begin(), divisors.end());
    for(int d : divisors) cout << d << " ";
}

// ============ GCD (EUCLIDEAN ALGORITHM) ============
// Recursive - O(log min(a, b))
int gcd(int a, int b) {
    if(b == 0) return a;
    return gcd(b, a % b);
}

// Iterative - O(log min(a, b))
int gcdIterative(int a, int b) {
    while(b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

// ============ LCM ============
int lcm(int a, int b) {
    return (a / gcd(a, b)) * b;  // Prevent overflow
}

// ============ DIGIT MANIPULATION ============
// Count digits - O(log n)
int countDigits(int n) {
    if(n == 0) return 1;
    int count = 0;
    while(n > 0) {
        count++;
        n /= 10;
    }
    return count;
}

// Reverse number - O(log n)
int reverseNumber(int n) {
    int reversed = 0;
    while(n > 0) {
        int digit = n % 10;
        reversed = reversed * 10 + digit;
        n /= 10;
    }
    return reversed;
}

// Sum of digits - O(log n)
int sumOfDigits(int n) {
    int sum = 0;
    while(n > 0) {
        sum += n % 10;
        n /= 10;
    }
    return sum;
}

// Check palindrome - O(log n)
bool isPalindrome(int n) {
    return n == reverseNumber(n);
}

// ============ ARMSTRONG NUMBER ============
bool isArmstrong(int n) {
    int original = n;
    int digits = countDigits(n);
    int sum = 0;
    
    while(n > 0) {
        int digit = n % 10;
        sum += pow(digit, digits);
        n /= 10;
    }
    
    return sum == original;
}

// ============ PERFECT NUMBER ============
bool isPerfect(int n) {
    if(n <= 1) return false;
    int sum = 1;
    
    for(int i = 2; i * i <= n; i++) {
        if(n % i == 0) {
            sum += i;
            if(i != n / i) {
                sum += n / i;
            }
        }
    }
    
    return sum == n;
}

// ============ SIEVE OF ERATOSTHENES ============
// Find all primes up to n - O(n log log n)
vector<bool> sieveOfEratosthenes(int n) {
    vector<bool> isPrime(n + 1, true);
    isPrime[0] = isPrime[1] = false;
    
    for(int i = 2; i * i <= n; i++) {
        if(isPrime[i]) {
            for(int j = i * i; j <= n; j += i) {
                isPrime[j] = false;
            }
        }
    }
    
    return isPrime;
}

// ============ MODULAR ARITHMETIC ============
// Modular exponentiation - O(log exp)
long long modPower(long long base, long long exp, long long mod) {
    long long result = 1;
    base %= mod;
    
    while(exp > 0) {
        if(exp & 1) {
            result = (result * base) % mod;
        }
        base = (base * base) % mod;
        exp >>= 1;
    }
    
    return result;
}

// Check if power of 2 - O(1)
bool isPowerOfTwo(int n) {
    return (n > 0) && ((n & (n - 1)) == 0);
}

// Fibonacci - O(n)
long long fibonacci(int n) {
    if(n <= 1) return n;
    long long a = 0, b = 1;
    for(int i = 2; i <= n; i++) {
        long long c = a + b;
        a = b;
        b = c;
    }
    return b;
}
```

### 🎯 Problem-Solving Patterns

1. **For Prime Problems**: Always optimize to √n, check for 2 separately
2. **For Divisor Problems**: Iterate till √n and count pairs
3. **For GCD/LCM**: Use Euclidean algorithm, avoid brute force
4. **For Digit Problems**: Use % 10 to extract, / 10 to remove
5. **For Large Numbers**: Apply modular arithmetic to prevent overflow
6. **For Multiple Queries**: Use Sieve for preprocessing

🎯 **Key Takeaway**: Mathematics is the backbone of competitive programming. Strong number theory skills enable you to optimize brute force solutions, handle large numbers efficiently, and recognize patterns that lead to elegant solutions.

</details>

<details open>
<summary><b>🔄 Day 5: Recursion Fundamentals</b></summary>
<br>

### 📖 Theoretical Concepts

| Concept | Explanation | Key Points |
|---------|-------------|------------|
| **What is Recursion?** | A function calling itself to solve smaller instances of the same problem | • Break problem into smaller subproblems<br>• Each call works on simpler input<br>• Trust the recursive process |
| **The Three Pillars** | 1. **Base Case**: Stopping condition<br>2. **Recursive Call**: Function calling itself<br>3. **Small Calculation**: Work done at each level | Base case prevents infinite recursion<br>Recursive call reduces problem size<br>Calculation combines results |
| **Call Stack** | Memory structure storing function calls | • Each call is pushed onto stack<br>• LIFO (Last In, First Out)<br>• Stack stores local variables & return address |
| **Space Complexity** | Recursion uses O(n) space for n recursive calls | Stack depth = recursion depth<br>Can lead to stack overflow for large n |
| **Types of Recursion** | • **Linear**: One recursive call per function<br>• **Binary**: Two recursive calls (e.g., Fibonacci)<br>• **Tail**: Recursive call is last operation | Tail recursion can be optimized by compiler |

### 💻 Practical Implementation

```cpp
#include <bits/stdc++.h>
using namespace std;

// ============ BASIC RECURSION ============
// Print something N times - O(n) time, O(n) space
void printNTimes(int n) {
    if(n == 0) return;
    cout << "Hello World" << endl;
    printNTimes(n - 1);
}

// ============ FUNCTIONAL RECURSION ============
// Print 1 to N - O(n)
void print1ToN(int n) {
    if(n == 0) return;
    print1ToN(n - 1);
    cout << n << " ";
}

// Print N to 1 - O(n)
void printNTo1(int n) {
    if(n == 0) return;
    cout << n << " ";
    printNTo1(n - 1);
}

// Sum of first N numbers
int sumN(int n) {
    if(n == 0) return 0;
    return n + sumN(n - 1);
}

// Factorial - O(n)
int factorial(int n) {
    if(n == 0 || n == 1) return 1;
    return n * factorial(n - 1);
}

// ============ PARAMETERIZED RECURSION ============
// Sum using parameterized approach
void sumNParameterized(int n, int sum) {
    if(n == 0) {
        cout << sum << endl;
        return;
    }
    sumNParameterized(n - 1, sum + n);
}

// Factorial - Tail recursion
int factorialTail(int n, int result = 1) {
    if(n == 0 || n == 1) return result;
    return factorialTail(n - 1, n * result);
}

// ============ MULTIPLE RECURSION CALLS ============
// Fibonacci - O(2^n) time, O(n) space
int fibonacci(int n) {
    if(n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

// ============ ARRAY RECURSION ============
// Reverse an array - O(n)
void reverseArray(int arr[], int left, int right) {
    if(left >= right) return;
    swap(arr[left], arr[right]);
    reverseArray(arr, left + 1, right - 1);
}

// Check palindrome - O(n)
bool isPalindrome(string str, int left, int right) {
    if(left >= right) return true;
    if(str[left] != str[right]) return false;
    return isPalindrome(str, left + 1, right - 1);
}

// ============ ADVANCED PATTERNS ============
// Print all subsequences - O(2^n)
void printSubsequences(int arr[], int index, int n, vector<int>& current) {
    if(index == n) {
        for(int x : current) cout << x << " ";
        if(current.empty()) cout << "{}";
        cout << endl;
        return;
    }
    
    current.push_back(arr[index]);
    printSubsequences(arr, index + 1, n, current);
    
    current.pop_back();
    printSubsequences(arr, index + 1, n, current);
}

// Power function - O(log n)
long long power(int base, int exp) {
    if(exp == 0) return 1;
    long long half = power(base, exp / 2);
    
    if(exp % 2 == 0) {
        return half * half;
    } else {
        return half * half * base;
    }
}

// GCD using recursion - O(log min(a,b))
int gcd(int a, int b) {
    if(b == 0) return a;
    return gcd(b, a % b);
}

// Tower of Hanoi - O(2^n)
void towerOfHanoi(int n, char from, char to, char aux) {
    if(n == 1) {
        cout << "Move disk 1 from " << from << " to " << to << endl;
        return;
    }
    
    towerOfHanoi(n - 1, from, aux, to);
    cout << "Move disk " << n << " from " << from << " to " << to << endl;
    towerOfHanoi(n - 1, aux, to, from);
}

// Generate permutations - O(n!)
void permute(string str, int left, int right) {
    if(left == right) {
        cout << str << endl;
        return;
    }
    
    for(int i = left; i <= right; i++) {
        swap(str[left], str[i]);
        permute(str, left + 1, right);
        swap(str[left], str[i]);
    }
}

// Binary Search - O(log n)
bool binarySearch(int arr[], int left, int right, int target) {
    if(left > right) return false;
    
    int mid = left + (right - left) / 2;
    
    if(arr[mid] == target) return true;
    if(arr[mid] > target) return binarySearch(arr, left, mid - 1, target);
    return binarySearch(arr, mid + 1, right, target);
}
```

### 🎯 Problems Solved & Mastery Checklist

#### **Basic Recursion**
- ✅ Print something N times
- ✅ Print name N times
- ✅ Print 1 to N using recursion
- ✅ Print N to 1 using recursion

#### **Functional Recursion**
- ✅ Sum of first N numbers
- ✅ Factorial of N
- ✅ Fibonacci number

#### **Parameterized Recursion**
- ✅ Sum using parameters
- ✅ Factorial using tail recursion

#### **Array & String Recursion**
- ✅ Reverse an array
- ✅ Check if string is palindrome
- ✅ Print all subsequences
- ✅ Count subsequences with sum K

#### **Divide & Conquer**
- ✅ Binary Search
- ✅ Merge Sort
- ✅ Quick Sort
- ✅ Power function (optimized)

#### **Advanced Patterns**
- ✅ Tower of Hanoi
- ✅ Generate all permutations
- ✅ N-Queens problem
- ✅ Sudoku Solver

### 🧠 Recursion Thinking Framework

```
┌─────────────────────────────────────────────────┐
│          THE RECURSION MINDSET                  │
├─────────────────────────────────────────────────┤
│                                                 │
│  1. IDENTIFY BASE CASE                          │
│     → What's the simplest input?                │
│     → When should recursion stop?               │
│                                                 │
│  2. ASSUME RECURSION WORKS                      │
│     → Trust that f(n-1) gives correct result    │
│     → Don't trace the entire recursion tree     │
│                                                 │
│  3. DEFINE RECURRENCE RELATION                  │
│     → How does f(n) relate to f(n-1)?           │
│     → What calculation connects them?           │
│                                                 │
│  4. ANALYZE COMPLEXITY                          │
│     → Time: Count recursive calls × work/call   │
│     → Space: Maximum recursion depth            │
│                                                 │
└─────────────────────────────────────────────────┘
```

### 📊 Time Complexity Analysis

| Pattern | Example | Time | Space |
|---------|---------|------|-------|
| **Linear Recursion** | Print N, Sum N | O(n) | O(n) |
| **Binary Recursion** | Fibonacci | O(2^n) | O(n) |
| **Divide & Conquer** | Binary Search | O(log n) | O(log n) |
| **Divide & Conquer** | Merge Sort | O(n log n) | O(n) |
| **Subsequences** | All subsequences | O(2^n) | O(n) |
| **Permutations** | All permutations | O(n!) | O(n) |

🎯 **Key Takeaway**: Recursion is thinking in reverse—trust that smaller problems solve themselves, define the relationship, and let the call stack handle the magic. Master the base case, understand the recursive leap, and you'll unlock the power to solve complex problems with elegant simplicity.

</details>

---

## 🗓️ Daily Quest Log & Progress Tracker

<div align="center">

| 📆 Day | 🎯 Quest Title | 📝 Topics Covered | 🏆 Status |
|--------|---------------|-------------------|-----------|
| 01 | [Language Basics](#) | I/O, Functions, Time Complexity, Conditionals, Loops | ✅ Complete |
| 02 | [Pattern Mastery](#) | Nested Loops, Spatial Logic, Pattern Engineering | ✅ Complete |
| 03 | [STL Toolkit](#) | Vectors, Sets, Maps, Iterators, Algorithms | ✅ Complete |
| 04 | [Basic Mathematics](#) | Number Theory, GCD/LCM, Digit Manipulation, Primes | ✅ Complete |
| 05 | [Recursion Basics](#) | Base Cases, Functional/Parameterized Recursion, Multiple Calls | ✅ Complete |
| 06 | Hashing Fundamentals | Frequency Counting, Hash Maps, Collision Handling | ⏳ In Progress |
| 07 | Arrays - Part I | Traversal, Insertion, Deletion, Two Pointer Technique | 🔜 Upcoming |
| 08-90 | 🌌 Uncharted Waters | Advanced Topics Await | 🗺️ To Be Explored |

</div>

---

## 🛠️ Arsenal of Tools

<div align="center">

```cpp
class CodingWarrior {
private:
    string primaryLanguage = "C++17 (ISO/IEC 14882:2017)";
    string IDE = "VS Code with C++ Extensions";
    string versionControl = "Git + GitHub";
    vector<string> debugTools = {"GDB", "Valgrind", "AddressSanitizer"};
    string compiler = "g++ -std=c++17 -O2 -Wall -Wextra";
    double motivationLevel = INFINITY;
    int coffeeCount = INT_MAX;
    
public:
    void solveProblems() {
        while (challengesRemaining > 0) {
            analyze();
            pseudocode();
            implement();
            test();
            
            if (!bugFree()) {
                debug();
                coffeeCount++;
            } else {
                celebrate();
                challengesRemaining--;
            }
        }
        
        cout << "🎉 WinterArc Complete! Level Up Unlocked!" << endl;
    }
    
    string getMotivation() {
        return "Every expert was once a beginner. Keep pushing! 💪";
    }
};
```

<br>

### 🎨 Technology Stack

<img src="https://skillicons.dev/icons?i=cpp,c,vscode,github,git,linux,bash&theme=dark" height="60" />

<br>

| Tool | Purpose | Mastery Level |
|------|---------|---------------|
| C++17 | Primary programming language | ████████░░ 80% |
| VS Code | Code editor with debugging | ████████░░ 80% |
| Git & GitHub | Version control & collaboration | ███████░░░ 70% |
| GDB | GNU Debugger for C++ | ██████░░░░ 60% |
| Linux | Development environment | ███████░░░ 70% |

<br>

**🎨 Brand Colors**: #667eea • #764ba2 • #f5576c • #10b981 • #a78bfa • #d97706

</div>

---

## 🎯 Power-Ups & Learning Resources

<div align="center">

### 🏰 Official TUF Resources

[![Striver's A2Z DSA Course](https://img.shields.io/badge/Striver's_A2Z_DSA_Course-FF4154?style=for-the-badge&logo=youtube&logoColor=white)](https://takeuforward.org/strivers-a2z-dsa-course/strivers-a2z-dsa-course-sheet-2)
[![TUF Website](https://img.shields.io/badge/TakeUForward-Website-667eea?style=for-the-badge&logo=google-chrome&logoColor=white)](https://takeuforward.org/)
[![YouTube Channel](https://img.shields.io/badge/YouTube-Channel-FF0000?style=for-the-badge&logo=youtube&logoColor=white)](https://www.youtube.com/@takeUforward)

### ⚔️ Practice Battlegrounds

[![LeetCode](https://img.shields.io/badge/LeetCode-FFA116?style=for-the-badge&logo=leetcode&logoColor=white)](https://leetcode.com/)
[![CodeForces](https://img.shields.io/badge/Codeforces-1F8ACB?style=for-the-badge&logo=codeforces&logoColor=white)](https://codeforces.com/)
[![CodeChef](https://img.shields.io/badge/CodeChef-5B4638?style=for-the-badge&logo=codechef&logoColor=white)](https://www.codechef.com/)
[![GeeksforGeeks](https://img.shields.io/badge/GeeksforGeeks-0F9D58?style=for-the-badge&logo=geeksforgeeks&logoColor=white)](https://www.geeksforgeeks.org/)
[![HackerRank](https://img.shields.io/badge/HackerRank-00EA64?style=for-the-badge&logo=hackerrank&logoColor=white)](https://www.hackerrank.com/)

### 📚 Additional Resources
- 📖 **Books**: "Introduction to Algorithms" (CLRS), "Competitive Programming 4"
- 🎥 **Channels**: Abdul Bari, William Fiset, Tushar Roy
- 📝 **Blogs**: CP-Algorithms, Codeforces Blogs, TopCoder Tutorials
- 🧩 **Practice**: AtCoder, SPOJ, USACO

</div>

---

## 🌐 Connect & Collaborate

<div align="center">

<img src="https://readme-typing-svg.herokuapp.com?font=Fira+Code&weight=500&pause=1000&color=F75C7E&center=true&vCenter=true&width=550&lines=Let's+build+something+amazing+together!+%F0%9F%9A%80;Open+to+collaborations+and+discussions+%F0%9F%A4%9D;Feel+free+to+reach+out+anytime!+%F0%9F%92%AC;Let's+grow+and+learn+together!+%F0%9F%8C%B1" alt="Connect Message" />

<br><br>

### 🔗 Find Me On

[![LinkedIn](https://img.shields.io/badge/LinkedIn-0077B5?style=for-the-badge&logo=linkedin&logoColor=white)](https://www.linkedin.com/in/sonamnarula/)
[![GitHub](https://img.shields.io/badge/GitHub-100000?style=for-the-badge&logo=github&logoColor=white)](https://github.com/SonamNarula)
[![LeetCode](https://img.shields.io/badge/LeetCode-FFA116?style=for-the-badge&logo=leetcode&logoColor=white)](https://leetcode.com/SonamNarula)
[![Email](https://img.shields.io/badge/Email-D14836?style=for-the-badge&logo=gmail&logoColor=white)](mailto:your.email@example.com)
[![Twitter](https://img.shields.io/badge/Twitter-1DA1F2?style=for-the-badge&logo=twitter&logoColor=white)](https://twitter.com/yourhandle)

<br>

### 💬 Let's Talk About
**Data Structures • Algorithms • Competitive Programming • Open Source • Tech Career Guidance • Collaboration Opportunities**

</div>

---

## 📈 GitHub Activity & Stats

<div align="center">

<img src="https://github-readme-stats.vercel.app/api?username=SonamNarula&show_icons=true&theme=radical&hide_border=true&bg_color=1a1b27&title_color=f5576c&icon_color=667eea&text_color=a78bfa" width="48%" />
<img src="https://github-readme-streak-stats.herokuapp.com/?user=SonamNarula&theme=radical&hide_border=true&background=1a1b27&stroke=f5576c&ring=667eea&fire=f5576c&currStreakLabel=a78bfa" width="48%" />

<br><br>

<img src="https://github-readme-stats.vercel.app/api/top-langs/?username=SonamNarula&layout=compact&theme=radical&hide_border=true&bg_color=1a1b27&title_color=f5576c&text_color=a78bfa" width="48%" />

<br><br>

![Activity Graph](https://github-readme-activity-graph.vercel.app/graph?username=SonamNarula&theme=react-dark&hide_border=true&area=true&bg_color=1a1b27&color=667eea&line=f5576c&point=a78bfa)

</div>

---

## 🎭 Philosophy & Motivation

<div align="center">

```
╔════════════════════════════════════════════════════════════════════╗
║                                                                    ║
║   "The master has failed more times than the beginner has          ║
║    even tried." — Stephen McCranie                                 ║
║                                                                    ║
║   🎯 Perfection is a myth — Progress is the reality                ║
║   🔥 Consistency beats intensity every single time                 ║
║   💡 Every bug is a lesson, every solution is a victory            ║
║   🚀 The goal: Better than yesterday, every single day             ║
║                                                                    ║
║   Code → Debug → Learn → Iterate → Master 🏆                       ║
║                                                                    ║
╚════════════════════════════════════════════════════════════════════╝
```

### 🔥 The WinterArc Mantra

```cpp
while (alive) {
    learn();
    practice();
    fail();
    learn();
    improve();
    repeat();
}

// Success is inevitable when you never quit 💪
```

</div>

---

## 🏆 Milestones & Achievements

<div align="center">

| 🎯 Milestone | 📅 Target Date | ✅ Status |
|-------------|---------------|-----------|
| Complete Basics (Day 1-5) | Week 1 | ✅ Achieved |
| Master Arrays & Hashing (Day 6-15) | Week 2-3 | ⏳ In Progress |
| Conquer Sorting & Searching (Day 16-25) | Week 4 | 🔜 Upcoming |
| Binary Trees & BST (Day 26-40) | Week 5-6 | 🔒 Locked |
| Dynamic Programming (Day 41-60) | Week 7-9 | 🔒 Locked |
| Graphs & Advanced Topics (Day 61-90) | Week 10-13 | 🔒 Locked |

<br>

### 🎖️ Badges Earned

![Day 1](https://img.shields.io/badge/✅_Day_1-Language_Basics-667eea?style=for-the-badge)
![Day 2](https://img.shields.io/badge/✅_Day_2-Patterns-f5576c?style=for-the-badge)
![Day 3](https://img.shields.io/badge/✅_Day_3-STL-10b981?style=for-the-badge)
![Day 4](https://img.shields.io/badge/✅_Day_4-Math-a78bfa?style=for-the-badge)
![Day 5](https://img.shields.io/badge/✅_Day_5-Recursion-d97706?style=for-the-badge)

</div>

---

## 🙏 Acknowledgments & Credits

<div align="center">

### Special Thanks To:

**Striver (Raj Vikramaditya)** — For the incredible A2Z DSA course  
**TakeUForward Community** — For constant motivation and support  
**Open Source Contributors** — For amazing tools and resources  
**Coffee ☕** — The real MVP behind every debug session

</div>

---

<div align="center">

## 🎮 Achievement Unlocked: README Champion 🏆

<img src="https://img.shields.io/badge/Crafted_with-💜_Passion_&_☕_Coffee-f5576c?style=for-the-badge&labelColor=1a1b27" />
<img src="https://img.shields.io/badge/Updated-Regularly-10b981?style=for-the-badge&labelColor=1a1b27" />
<img src="https://img.shields.io/badge/Star-⭐_This_Repo-667eea?style=for-the-badge&labelColor=1a1b27" />

<br><br>

**#TUF #WinterArc #DSA #CodingJourney #CPlusPlus #StriverA2Z #ConsistencyIsKey #NeverGiveUp #90DaysOfCode**

<br>

### 💖 If this repository helped you, consider giving it a ⭐

<br>

<img width="100%" src="https://capsule-render.vercel.app/api?type=waving&color=gradient&customColorList=6,11,20&height=120&section=footer" />

</div>
